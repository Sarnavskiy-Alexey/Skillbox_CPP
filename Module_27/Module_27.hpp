#ifdef __MODULE_27__
#pragma once

#include <string>
const std::string string_tasks[] = {
    "\t\t\tЗадание 1. Реализация деревни эльфов\n  Что нужно сделать\n  Лесные эльфы расположили свою деревню в лесу, прямо на деревьях. Нужно расселить эльфов по веткам деревьев, а затем подсчитать общее количество соседей определённого эльфа.\n  Всего в лесу пять деревьев, каждое из которых генерируется с помощью случайных чисел, заданных в указанных далее диапазонах. На каждом дереве есть 3–5 основных больших ветвей. На каждой большой ветке расположены ещё 2-3 средние ветки. Дома эльфов построены на больших и на средних ветках. Более мелкие ветви не рассматриваются в этой задаче.\n  В начале программы пользователь размещает в каждом доме по одному эльфу. Делается это с помощью последовательного перебора всех имеющихся домов и запроса имени заселяемого эльфа через стандартный ввод. Если было введено None в качестве имени, то дом пропускается и не заселяется никем.\n  После этого требуется найти определённого эльфа по имени. Имя искомого эльфа вводится через стандартный ввод. Для найденного эльфа нужно вывести общее количество эльфов, живущих вместе с ним на одной большой ветви. Это и будет искомое количество соседей.\n\n  Советы и рекомендации:\n  И для представления деревьев, и для представления больших и средних ветвей следует использовать один и тот же класс (например Branch) с полем, которое будет обозначать родительскую ветвь, и полем, обозначающим дочерние ветви. У самого дерева, в свою очередь, родительская ветвь будет всегда нулевой, то есть nullptr.\n  Функцию поиска эльфа в дереве можно реализовать с помощью рекурсивного метода в классе Branch, который сначала поищет эльфа в себе, а потом уже на дочерних ветвях.\n  Чтобы лучше представлять структуру дерева и понимать, как получать его вершину, взгляните на данный метод:\n      Branch* getTopBranch()\n      {\n          //Если это дерево\n          if (parent == nullptr) return nullptr; \n          //Если это средняя ветка\n          if (parent->parent == nullptr) return parent;\n          //Если это маленькая ветка\n          return parent->getTopBranch();\n      }\n",
    "\t\t\tЗадание 2. Иерархия геометрических фигур\n  Что нужно сделать\n  Спроектируйте иерархию классов различных фигур: круг, квадрат, равносторонний треугольник, прямоугольник.\n  Для всех этих фигур есть общие поля-данные — это координаты их центра и условный цвет фигуры: красный, синий или зелёный.\n  Для отдельных фигур есть и уникальные параметры: радиус для круга, длина ребра для квадрата и равностороннего треугольника, ширина и высота для прямоугольника. Все данные — это вещественные числа с удвоенной точностью.\n  Для каждой из фигур требуется определить метод нахождения площади фигуры, а также метод нахождения прямоугольника, описывающего фигуру полностью (он может быть больше зоны фигуры, но не меньше).\n  Для лучшего понимания задачи приведена иллюстрация. На ней разными цветами помечены площади фигур, а пунктиром изображены прямоугольники, описывающие фигуры.\n  Для теста предусмотрите ввод пользователем команд: circle, square, triangle, rectangle, соответствующих фигурам. Команды должны получать параметры фигур и выводить их цвет, площадь и описывающий прямоугольник с координатами.\n\n  Советы и рекомендации:\n  Для цвета фигуры вы можете использовать собственный тип enum, в котором может содержаться и константа отсутствия цвета — None.\n  Площадь треугольника считается как length * length * std::sqrt(3) / 4; где length — сторона. Площадь круга — как atan(1) * 4 * radius;\n  Геометрические формулы вы можете найти в интернете.\n",
    "\t\t\tЗадание 3. Симуляция работы компании\n  Что нужно сделать\n  Реализуйте симуляцию работы компании. В компании существует вертикальное управление с иерархией. Есть основные рабочие, подчинённые, разбитые на команды. У каждой команды есть менеджер среднего звена. Всей компанией руководит глава компании. У всех сотрудников, включая руководителя, есть имена.\n  Глава компании выполняет стратегическое управление. Он определяет основной вектор движения — задачи верхнего уровня. Менеджеры среднего звена разбивают эти задачи на подзадачи и раздают их своим подчинённым. Подчинённые выполняют работу.\n  - Реализация данной логики должна проходить упрощённым образом. Указания главы компании поступают из стандартного ввода и являются не более чем целочисленными идентификаторами.\n  - Данные идентификаторы служат зерном для генератора случайных чисел. Каждый из менеджеров, принимая себе эту целочисленную команду, добавляет к ней свой порядковый номер и вызывает с результирующей суммой функцию std::srand().\n  - На основе этой суммы вычисляется общее количество задач, которое требуется выполнить данной командой, — от 1 до количества работников в группе. Всего есть три типа задач для работников: A, B и C. Они тоже выбираются случайно и распределяются между незанятыми рабочими.\n  - При старте программы пользователь указывает в стандартном вводе количество команд и количество работников в каждой из команд.\n  - Далее пользователь вводит целые числа, которые соответствуют указаниям руководителя компании. Когда какой-то работник или менеджер получил указания или задачу, об этом сообщается в стандартный вывод, включая имя работающего сотрудника. Программа завершается, когда все работники заняты какими-то задачами.\n\n  Советы и рекомендации:\n  Пользуйтесь всем изученным в модуле, включая иерархии классов для представления сотрудников и указатель this, если потребуется.\n  Чтобы проинициализировать генератор случайных чисел, используйте std::srand(hash); где hash — некое случайное и уникальное значение, например, ID вашей группы и команды. Для получения количества задач используйте полученный генератор случайных чисел так: int tasksCount = rand() % (team->workers.size() + 1);\n"
};

extern const std::string equals;

void Task_27_1();
void Task_27_2();
void Task_27_3();
#endif
