#ifdef __MODULE_31__
#pragma once

#include <string>
const std::string string_tasks[] = {
    "\t\t\tЗадание 1. Использование умного указателя\n  Что нужно сделать:\n  1. Реализуйте класс Dog, который использует стандартный умный указатель shared_ptr для класса Toy.\n  2. Реализуйте у класса Dog метод getToy, с помощью которого собака подбирает игрушку.\n    a. Если у собаки уже есть эта игрушка, необходимо вывести в консоль фразу: I already have this toy.\n    b. Если в данный момент игрушка находится у другой собаки, нужно вывести в консоль: Another dog is playing with this toy.\n    c. Если игрушка свободна, собака подбирает её.\n  3. Реализуйте у класса Dog метод dropToy, с помощью которого собака бросает игрушку на пол, после чего другая может подобрать её.\n    a. Если у собаки в этот момент нет игрушки, в консоль необходимо вывести: Nothing to drop.\n\n  Советы и рекомендации:\n  - Чтобы узнать, у скольких собак в данный момент есть игрушка, можно использовать метод use_count() у класса shared_ptr. При этом необходимо учитывать, что создание shared_ptr от класса Toy тоже увеличивает показатели счётчика.\n  - Чтобы увидеть удаление класса Toy, используйте следующее определение:\n  class Toy {\n  public:\n     Toy(const std::string& name) {\n         name_ = name;\n     }\n     std::string getNmae() {\n         return name_;\n     }\n     ~Toy() {\n         std::cout << \"Toy \" << name_ << \" was dropped \" << std::endl;\n     }\n  private:\n     std::string name_;\n  };\n",
    "\t\t\tЗадание 2. Реализация умного указателя\n  Что нужно сделать:\n  1. Реализуйте умный указатель shared_ptr_toy с распределённым доступом и механикой подсчёта ссылок для класса Toy, реализованного в задании.\n  Указатель должен: \n    a. иметь все стандартные методы класса,\n    b. быть функциональной заменой использованию shared_ptr<Toy>.\n  2. Реализуйте свободную функцию make_shared_toy, которая принимает набор аргументов и конструирует игрушку от названия или при помощи копии другой игрушки.\n\n  Советы и рекомендации:\n  Не забудьте уменьшить число ссылок на единицу в деструкторе умного указателя. Когда на счётчике появится значение 0, удалите объект.\n  - Вы можете использовать перегрузки под разные типы. Их количество ограничено.\n\n  Чек-лист для проверки задания:\n  - Класс называется shared_ptr_toy.\n  - Реализованы конструктор, конструктор копий, оператор присваивания копированием, деструктор и функция make_shared.\n",
    "\t\t\tЗадание 3. Реализация класса графа (дополнительное задание)\n  Что нужно сделать:\n  1. Прочитайте, что такое графы в дискретной математике, как граф можно представить в программе, что такое матрицы смежности и списки смежности:\n    - «Просто о графах. Попытка популяризации»;\n    - «Теория графов. Дискретная математика»;\n    - «Представление графа с помощью матриц смежности, инцидентности и списков смежности».\n  2. У вас есть базовый интерфейс для представления ориентированного графа. Напишите две реализации интерфейса:\n    - ListGraph, хранящий граф в виде массива списков смежности;\n    - MatrixGraph, хранящий граф в виде матрицы смежности.\n  3. Реализуйте конструктор, принимающий IGraph. Такой конструктор должен скопировать переданный граф в создаваемый объект. Обратите внимание, что иногда в одну реализацию графа копируется другая. Реализуйте все конструкторы копий и операторы присваивания, если это необходимо.\n\n  Советы и рекомендации:\n  Во всех алгоритмах поиска вам потребуются рёбра для вершин. Для этого используйте std::unordered_set и его метод contains.\n  Пример кода: \n  class IGraph {\n  public:\n  virtual ~IGraph() {}\n  IGraph() {};\n  IGraph(IGraph *_oth) {};\n  virtual void AddEdge(int from, int to) = 0; // Метод принимает вершины начала и конца ребра и добавляет ребро\n  virtual int VerticesCount() const = 0; // Метод должен считать текущее количество вершин\n  virtual void GetNextVertices(int vertex, std::vector<int> &vertices) const = 0; // Для конкретной вершины метод выводит в вектор «вершины» все вершины, в которые можно дойти по ребру из данной\n  virtual void GetPrevVertices(int vertex, std::vector<int> &vertices) const = 0; // Для конкретной вершины метод выводит в вектор «вершины» все вершины, из которых можно дойти по ребру в данную\n  };\n\n  Чек-лист для проверки задания:\n  - Реализованы два класса-наследника, имплементирующие корректные алгоритмы работы с графом как с матрицей смежности и списками смежности.\n"
};

extern const std::string equals;

void Task_31_1();
void Task_31_2();
void Task_31_3();
#endif
