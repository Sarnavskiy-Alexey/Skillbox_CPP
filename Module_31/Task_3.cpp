#ifdef __MODULE_31__
/* Задание 3. Реализация класса графа (дополнительное задание)
 *  Что нужно сделать:
 *  1. Прочитайте, что такое графы в дискретной математике, как граф можно представить в программе, *     что такое матрицы смежности и списки смежности:
 *     - «Просто о графах. Попытка популяризации»;
 *     - «Теория графов. Дискретная математика»;
 *     - «Представление графа с помощью матриц смежности, инцидентности и списков смежности».
 *  2. У вас есть базовый интерфейс для представления ориентированного графа. Напишите две реализации
 *     интерфейса:
 *     - ListGraph, хранящий граф в виде массива списков смежности;
 *     - MatrixGraph, хранящий граф в виде матрицы смежности.
 *  3. Реализуйте конструктор, принимающий IGraph. Такой конструктор должен скопировать переданный
 *     граф в создаваемый объект. Обратите внимание, что иногда в одну реализацию графа копируется
 *     другая. Реализуйте все конструкторы копий и операторы присваивания, если это необходимо.
 *  
 *  Советы и рекомендации:
 *  Во всех алгоритмах поиска вам потребуются рёбра для вершин. Для этого используйте
 *  std::unordered_set и его метод contains.
 *  
 *  Пример кода: 
 *  
 *  class IGraph {
 *  public:
 *      virtual ~IGraph() {}
 *      IGraph() {};
 *      IGraph(IGraph *_oth) {};
 *      virtual void AddEdge(int from, int to) = 0; // Метод принимает вершины начала и конца ребра
 *                                                     и добавляет ребро
 *      virtual int VerticesCount() const = 0; // Метод должен считать текущее количество вершин
 *      virtual void GetNextVertices(int vertex, std::vector<int> &vertices) const = 0; // Для
 *                                          конкретной вершины метод выводит в вектор «вершины» все
 *                                          вершины, в которые можно дойти по ребру из данной
 *      virtual void GetPrevVertices(int vertex, std::vector<int> &vertices) const = 0; // Для
 *                                          конкретной вершины метод выводит в вектор «вершины» все
 *                                          вершины, из которых можно дойти по ребру в данную
 *  };
 *  
 *  Чек-лист для проверки задания:
 *  Реализованы два класса-наследника, имплементирующие корректные алгоритмы работы с графом как с
 *  матрицей смежности и списками смежности. */

#include <iostream>
#include "Module_31.hpp"

void Task_31_3() {
    std::cout << equals << string_tasks[2] << equals;

    std::cout << "Task is not complete yet! Sorry!\n";
}
#endif
