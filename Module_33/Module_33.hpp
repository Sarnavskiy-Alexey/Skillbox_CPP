// #ifdef __MODULE_33__
#pragma once

#include <string>
const std::string string_tasks[] = {
    "\t\t\tЗадание 1. Работа корзины с покупками\n  Что нужно сделать:\n  Реализуйте простую и безопасную модель работы корзины онлайн-магазина.\n  В начале программы вы заполняете базу данных самого магазина через стандартную консоль. Каждый элемент этой базы данных состоит из двух компонентов — артикула и количества штук.\n  Корзина должна поддерживать следующие операции: добавление товара с указанным его количеством — add, удаление товара с указанным количеством — remove. Обе операции принимают артикул товара в виде строки и количество в виде целого числа.\n  При вводе аргументов к операциям должна осуществляться их валидация. Артикул должен быть в базе данных магазина, количество не должно превышать количество доступного продукта на складе (при удалении — в корзине).\n\n  Рекомендации:\n  В качестве контейнера для базы данных и самой корзины можете использовать std::map.\n  Если пользователь ввёл некорректную информацию, то лучше выбросить std::invalid_argument, в других случаях — runtime_error.\n\n  Что оценивается:\n  Корректность логики работы при использовании исключений.\n",
    "\t\t\tЗадание 2. Игра по ловле рыбы\n  Что нужно сделать:\n  Реализуйте простую игру-симуляцию ловли рыбы. Игровое поле представляет собой девять секторов условного пруда. В начале игры в одном из этих секторов с помощью генератора случайных чисел оказывается рыба. Точно так же, случайным образом, по секторам пруда распределяются и три сапога. Сапог и рыба при этом не могут находиться в одном и том же секторе одновременно, как и несколько сапог сразу в одном из секторов.\n  Игрок закидывает удочку с приманкой в один из секторов, номер которого вводится стандартным способом через консоль. Задача игрока — угадать сектор, в котором находится рыба и, таким образом, поймать её. Если игрок попал на пустой сектор, то удочку надо забросить повторно. Если игрок поймал сапог, то игра завершается с отрицательным результатом.\n  Реализовать задачу нужно с помощью исключений: когда успешный заброс удочки генерирует специальное пользовательское исключение, после чего программа должна завершиться и оповестить пользователя об успешной рыбалке и количестве попыток, которое ему для этого потребовалось. Если же был пойман сапог, то должно выводиться сообщение о неудачной ловле.\n\n  Рекомендации:\n  Вспомните, что вы можете выбросить в качестве исключения произвольный тип данных. Это может быть и сапог, и рыба.\n  В функции main потребуется расположить рыбу случайным образом. Для этого сделайте std::srand(std::time(nullptr)); а затем само расположение: field[std::rand() % 9].fish = new Fish(); Благодаря оператору % вы не выйдете за пределы массива.\n\n  Что оценивается\n  Корректность работы игровой логики. Точность использования исключений.\n",
    "\t\t\tЗадание 3. Реестр данных на шаблонах\n  Что нужно сделать\n  С помощью шаблонов реализуйте простой класс реестра, хранящий произвольные типы значений по ключам произвольного типа. Ключи при этом могут повторяться.\n  Реестр должен поддерживать следующие операции: добавление элемента с ключом, удаление элементов с заданным ключом, вывод всех значений с ключами в консоль, поиск элементов по ключу.\n  Для тестирования программы предусмотрите ввод данных и команд из стандартной консоли:\n  - add — добавить элемент с ключом;\n  - remove — удалить все элементы с заданным ключом;\n  - print — напечатать на экране все элементы с их ключами;\n  - find — найти все элементы по их ключу.\n  Данный словарь должен работать на значениях и ключах следующих типов: int, double, std::string.\n\n  Рекомендации:\n  - Для реализации можете использовать стандартный шаблон std::vector, который в свою очередь уже будет хранить ваши пары ключей и значений.\n  - Сама пара ключа и значения как раз и будет классом (или струкурой), шаблонизированным двумя типами: типом значения и типом ключа.\n  - При желании вы можете создать отдельную шаблонизированную функцию с вводом команд и их данных.\n\n  Что оценивается:\n  Корректность работы логики программы, реализованной с помощью шаблонов.\n",
    "\t\t\tЗадание 4. Среднее арифметическое число в массиве\n  Что нужно сделать:\n  Реализуйте шаблонную функцию подсчёта среднего арифметического числа в массиве скалярных чисел произвольного типа. Это может быть int, double, float и так далее.\n  Ввод данных массива и вывод результата производится через стандартную консоль.\n\n  Рекомендации:\n  Для простоты можете реализовать подсчёт в массиве фиксированной длины.\n  Функцию ввода данных массива тоже рекомендуется реализовать как шаблонную.\n  Обе функции имеют похожую сигнатуру вида:\n      template < typename T >\n      void input(T array[8])\n      {\n          std::cout << \"Fill the array (8):\";\n          for (int i = 0; i < 8; ++i)\n          {\n      /*ввод отдельных элементов*/    \n          }\n      }\n\n  Что оценивается:\n  Корректность работы программы при различных пользовательских данных и различных типах используемых данных массива.\n"
};

extern const std::string equals;

void Task_33_1();
void Task_33_2();
void Task_33_3();
void Task_33_4();
// #endif
