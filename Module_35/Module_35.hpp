#ifdef __MODULE_35__
#pragma once

#include <string>
const std::string string_tasks[] = {
    "\t\t\tЗадание 1 (к уроку 2)\n  Цель задания:\n  Закрепить работу с нововведениями в базовых конструкциях языка.\n\n  Что нужно сделать:\n  Вспомните пример с range-based циклом по закрытию файлов:\n      for(auto ¤tFile : files)\n          currentFile.close();\n\n  По аналогии распечатайте числа от 1 до 5, используя auto и initializer_list.\n",
    "\t\t\tЗадание 2 (урок 3)\n  Цель задания:\n  Поработать с новыми структурами данных.\n\n  Что нужно сделать:\n  Так как std::unordered_set позволяет нам быстро определять, есть ли указанный ключ в контейнере, мы можем использовать его для фильтрации уникальных чисел.\n  Создайте лямбда-выражение, принимающее на вход std::vector<int>, в котором содержатся числа, которые могут повторяться. Внутри лямбды создайте unordered_set и при помощи него определяйте, сколько раз текущее число вам встречалось раньше. В результате верните std::unique_ptr<std::vector<int>>, содержащий числа без повторов. При проходе по контейнеру используйте новый формат цикла for и ключевое слово auto. \n",
    "\t\t\tЗадание 3 (к уроку 4)\n  Цель задания:\n  Поработать с файловой системой, используя новую библиотеку std::filesystem.\n\n  Что нужно сделать:\n  В нашем арсенале теперь есть возможность рекурсивно проходить по каталогам, то есть получить список всех файлов, каталогов (и подкаталогов), которые содержатся по указанному пути. Для этого в стандартной библиотеке есть std::filesystem::recursive_directory_iterator, принимающий на вход путь, который он будет обходить рекурсивно. На каждом шаге он будет выдавать очередной путь, это может быть как каталог, так и обычный файл. Например, код\n      for(auto& p: fs::recursive_directory_iterator(\"D:\\\\dir1\"))\n          std::cout << p.path() << '\\n';\n  выведет полные пути ко всем файлам и подкаталогам в директории D:\\dir1. Вызов p.path() возвращает объект типа std::filesystem::path, который позволяет:\n    1. Определить, файл это или каталог при помощи метода is_regular_file().\n    2. Получить расширение для обычного файла при помощи метода extension().\n  При помощи метода compare() можно сравнить расширение с произвольной строкой: p.path().extension().compare(“.torrent”).\n  Создайте лямбда-функцию, которая принимает на вход путь в файловой системе и искомое расширение в виде строки, а возвращает список имён файлов, которые имеют данное расширение(). Объявление нашей функции может начинаться так:\n      auto recursiveGetFileNamesByExtension =\n          [](std::filesystem::path path,\n              const std::string extension)\n"
};

extern const std::string equals;

void Task_35_1();
void Task_35_2();
void Task_35_3();
#endif
