#ifdef __MODULE_14__
#pragma once

const std::string string_tasks[] = {
    "\t\t\tЗадание 1. Банкетный стол\n  По поводу успешного прохождения двумерных массивов собирается банкет, организуется стол на 12 персон. Есть два VIP-места, они рядом во главе стола. Стол протяжён в длину, места расположены в два ряда. Каждый пришедший должен быть «упакован» соответствующим образом. Во-первых, столовые приборы: по три на каждого человека (вилка, ложка, нож) и одна маленькая дополнительная ложечка для VIP-персон (для десерта). Во-вторых, тарелки: каждому по две (для первого и второго блюда) и ещё одна тарелка для VIP-персон (для десерта). В-третьих, стулья: минимум один для каждого гостя. Заведите соответствующие двумерные массивы для количества приборов, посуды и стульев и проинициализируйте их.\n  Но это ещё не всё. На банкете после инициализации происходят некоторые события. Пришедшая на пятое место первого ряда дама привела с собой ребёнка, и поэтому на данное место был приставлен ещё один стул. С третьего места во втором ряду в неизвестном направлении была украдена ложка. Одна из VIP-персон (любая) поделилась своей ложкой с тем, кто остался без ложки, и стала есть суп десертной. За ненадобностью официант забрал у VIP-гостя одну десертную тарелку, ведь есть десерт ложкой, которая уже побывала уже в супе, неприлично. Больше без происшествий, однако эти события на банкете надо отразить в инициализированных ранее массивах.\n",
    "\t\t\tЗадание 2. Крестики-нолики\n  Старая добрая игра на страницах всех школьных тетрадей. Поле размером 3 × 3 представлено в виде двумерного массива с типом элементов char. Участвуют два игрока, они ходят по очереди и ставят в указанные ими в стандартном вводе координаты свой символ — X или O (буквы латинского алфавита). Как только у одного из игроков будет установлено подряд три крестика или три нолика, он побеждает. Если свободных клеток не осталось, а трёх совпадающих элементов не найдено, то объявляется ничья. Для простоты не будем рассматривать диагональные совпадения — только строго вертикальные и строго горизонтальные.\n  Изначально всё поле инициализируется символом пробела — ‘ ‘(для обозначения пробела кавычки одинарные и в одну сторону). Это можно сделать сразу при объявлении либо с помощью вложенного цикла. На каждом ходе при занятой клетке или при неверных координатах этой клетки должно быть выведено сообщение, и игрок должен указать координаты клетки повторно. После каждого хода надо выводить в консоль текущее состояние всего игрового поля для наглядности.\n",
    "\t\t\tЗадание 3. Матрицы\n  Требуется реализовать небольшую программу для сравнения двух двумерных матриц размером 4 × 4 на предмет их полного равенства. Если матрицы равны друг другу, необходимо взять одну из матриц и привести её к диагональному виду. Программа принимает на вход две целочисленные матрицы A и B, которые вводятся с помощью std::cin, и сравнивает их на предмет полного равенства. Если матрицы равны, то об этом сообщается в стандартном выводе. Алгоритм должен быть по возможности оптимальным и не проводить лишних операций. Если матрицы не равны, выводится соответствующее сообщение и выполнение программы прекращается. Если матрицы равны, то из них выбирается одна и преобразуется в диагональную. Конвертация в диагональную форму делается путём простейшего зануления всех элементов, лежащих вне главной диагонали. Напомню, что диагональная матрица — это такая матрица, у которой все элементы вне диагонали равны нулю. Диагональ матрицы, в свою очередь, — это все элементы, расположенные по диагонали от первого элемента первой строки до последнего элемента последней строки. Итоговую диагональную матрицу можно расположить на месте прежней матрицы, не используя дополнительных переменных. Результат преобразования требуется вывести в консоль для проверки. Ищите именно оптимальное решение, оно довольно простое.\n",
    "\t\t\tЗадание 4. Умножение матрицы на вектор\n  Реализуйте частный случай умножения матрицы на матрицу, а именно умножение вектора на матрицу. Эта операция распространена в компьютерной индустрии в целом и в компьютерной графике в частности, поэтому это будет хорошим упражнением.\n  Итак, у нас есть четырёхкомпонентный вектор b, представленный с помощью массива, и матрица a размером 4 × 4, представленная в виде двумерного массива. Их произведением будет новый четырёхэлементный вектор c. Его компоненты будут суммой произведений элемента вектора b на строку матрицы a. Индекс столбца при этом равен индексу соответствующей компоненты вектора b, который мы и рассчитываем.\n  Все входные данные, матрица a и вектор b вносятся из пользовательского ввода.  Итоговый вектор c надо вывести в консоль (std::cout). Тип данных элементов — всегда float. Желательно реализовать этот алгоритм с помощью вложенного цикла на умножение колонки.\n",
    "\t\t\tЗадание 5. Пупырка\n  После посылки из Китая осталась спецплёнка для бережной перевозки груза — пупырка. Всего в пупырке 12 на 12 шариков-пузырьков. Состояние любого пузырька: он либо целый, либо нет, то есть true или false (тип массива — bool). Для начала требуется реализовать отдельную функцию инициализации пупырки начальным состоянием: полностью целая пупырка, все элементы true.\n  Программа заключается в последовательном лопании целых регионов пузырьков. Перед каждым таким лопанием надо показывать пользователю полностью всю плёнку: o — это целый пузырёк, x — лопнутый. Это тоже надо выделить в отдельную функцию. Итак, как выглядит само лопание. Пользователь вводит две координаты: начала региона и конца региона. Процедура лопания пузырей должна быть реализована с помощью отдельной функции, все аргументы должны проверяться на валидность, что они в в рамках диапазона возможных значений, иначе должна быть выведена ошибка. После лопания каждого пузыря, который не был ещё лопнут до того, в консоль должно выводиться сообщение “Pop!”.\n  Лопание должно продолжаться до последнего пузырька. Как только вся пупырка потрачена, программа заканчивает выполнение. Вы можете подсчитать окончание в самой функции по отображению пузырьков плёнки, так как функция выполняется после каждого лопания.\n",
    "\t\t\tЗадание 6. Проход змейкой (дополнительное задание)\n  Есть двумерный массив целых чисел размером 5 на 5 элементов. Его надо инициализировать и отобразить на экране. Особенность именно в способе этой инициализации. Элементы должны быть инициализированы не последовательно, а змейкой: в конце каждой строки мы должны не переходить к первому элементу следующей строки, а начать наоборот, с последнего элемента и так далее. В конечном отображении массива числа должны быть упорядочены по возрастанию, но змеевидно от строке к строке. Сама же последовательность чисел — это простое линейное возрастание от 0 до 24, для её учёта можно завести отдельную переменную.\n  Попытайтесь решить эту задачу используя минимальное количество временных переменных и без условных переходов if. Если вы найдёте формулу индексации, будет замечательно! Она может быть весьма витиеватой..\n",
    "\t\t\tЗадание 7. Почти «Майнкрафт» (дополнительное задание)\n  Нам предстоит сделать некое подобие «Майнкрафта». Миллионов не обещаю, но это интересная задача на пространственное мышление. У нас есть небольшой квадратный ландшафт, размером 5 × 5 секторов. В каждом секторе располагается блок (столбик) ландшафта, максимальная высота которого — 10 блоков. Текущая высота каждого такого блока задаётся пользователем в начале программы. Итоговая задача: используя трёхмерный массив, вывести в стандартный вывод горизонтальное сечение (или горизонтальный срез) нашего небольшого мира. Сам мир как раз должен быть представлен в виде трёхмерного массива. Его горизонтальный срез — это двумерный массив, который надо отобразить в виде единиц и нулей. 0 — это отсутствие элемента на данном уровне в данной точке, 1 — элемент есть. Уровень среза от 0 до 9 включительно также задаётся в стандартном вводе.\n  Пример выполнения\n  input matrix of heights:\n    5 5 5 5\n    4 4 4 4\n    3 2 2 3\n    1 1 1 1\n  input slice: 4\n    1 1 1 1\n    1 1 1 1\n    0 0 0 0\n    0 0 0 0\n  input slice: 3\n    1 1 1 1\n    1 1 1 1\n    1 0 0 1\n    0 0 0 0\n",
    "\t\t\tЗадание 8. Морской бой (дополнительное задание)\n  Требуется реализовать упрощённую игру в морской бой. Игровое поле размером 10 на 10 клеток. Участвуют два игрока. В арсенале каждого из них 4 маленьких кораблика размером в одну клетку, 3 небольших корабля размером в две клетки, 2 средних корабля размером в три клетки и один большой корабль размером в четыре клетки. Для простоты клетки поля пронумерованы по вертикали от 0 до 9 и по горизонтали от 0 до 9. Мы не будем использовать классические наименования клеток, такие как B4, C6, а просто два индекса. Вначале игроки по очереди расставляют корабли, начиная с самых маленьких и заканчивая большими. Маленькие корабли в одну клетку расставляются с помощью указания одной клетки-точки на поле, к примеру 2,1. Корабли размерностью от двух клеток и выше расставляются с помощью координат их начала и конца, к примеру: 0,1–0,3. Корабли могут быть установлены только строго вертикально или горизонтально. Установка корабля по диагонали недопустима, об этом тоже надо сообщить пользователю. Если корабль не может быть размещён на заданных клетках из-за того, что он столкнётся с другим кораблём (окажется на его клетках) или выйдет за пределы поля, то игроку должно быть сделано предупреждение, после которого он должен переставить корабль на новые валидные координаты. В нашем упрощённом варианте игры мы не будем обсчитывать соприкосновения кораблей друг с другом, а потому корабли вполне можно будет размещать друг к другу вплотную, борт к борту. После того как все корабли расставлены, начинается игра. Игроки по очереди атакуют друг друга, называя координаты выстрела. После выстрела в консоль выводится информация о его результате: попал или мимо. Если выстрел успешен, клетка, на которой был корабль (или его фрагмент), затирается и становится пустой. Игра заканчивается тогда, когда все корабли одной из сторон будут полностью уничтожены. Как только это произойдёт, в консоль выводится информация с номером игрока, который победил.\n"
};

extern const std::string equals;

void Task_14_1();
void Task_14_2();
void Task_14_3();
void Task_14_4();
void Task_14_5();
void Task_14_6();
void Task_14_7();
void Task_14_8();
#endif
