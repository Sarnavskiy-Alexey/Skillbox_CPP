#ifdef __MODULE_14__
/* Задание 5. Пупырка
 *  После посылки из Китая осталась спецплёнка для бережной перевозки груза — пупырка. Всего в
 *  пупырке 12 на 12 шариков-пузырьков. Состояние любого пузырька: он либо целый, либо нет, то есть
 *  true или false (тип массива — bool). Для начала требуется реализовать отдельную функцию
 *  инициализации пупырки начальным состоянием: полностью целая пупырка, все элементы true.
 *  
 *  Программа заключается в последовательном лопании целых регионов пузырьков. Перед каждым таким
 *  лопанием надо показывать пользователю полностью всю плёнку: o — это целый пузырёк, x — лопнутый.
 *  Это тоже надо выделить в отдельную функцию. Итак, как выглядит само лопание. Пользователь вводит
 *  две координаты: начала региона и конца региона. Процедура лопания пузырей должна быть
 *  реализована с помощью отдельной функции, все аргументы должны проверяться на валидность, что они
 *  в в рамках диапазона возможных значений, иначе должна быть выведена ошибка. После лопания
 *  каждого пузыря, который не был ещё лопнут до того, в консоль должно выводиться сообщение “Pop!”.
 *  
 *  Лопание должно продолжаться до последнего пузырька. Как только вся пупырка потрачена, программа
 *  заканчивает выполнение. Вы можете подсчитать окончание в самой функции по отображению пузырьков
 *  плёнки, так как функция выполняется после каждого лопания.
 *  
 *  Советы и рекомендации:
 *  - Обратите внимание, что лопание пузырей делается с помощью региона, а не одной точки.
 *  - Регион задаётся двумя координатами, это координаты углов прямоугольника.
 *  - При лопании региона достаточно запустить цикл только по этим элементам. Не нужно проходить
 *    каждый раз по всей матрице.
 *  - Всю область плёнки удобно представить в виде двумерного массива типа bool.
 *  - Инициализировать вручную такой массив сложно, лучше воспользоваться вложенными циклами.
 *  - Для проверки на целостность одной ячейки (если вы используете тип bool) можно не сравнивать её
 *    с истиной, а указать в условии имя переменной.
 *  Например, вместо:
 *      if (shell[i][j] == true)
 *      {
 *          ...
 *      }
 *  Достаточно записать:
 *      if (shell[i][j])
 *      {
 *          ...
 *      }
 *  Такой трюк можно проделывать с переменными типа bool.
 *  
 *  Что оценивается:
 *  - Программа заканчивает выполнение только после того, как не осталось целых пузырей.
 *  - Лопание пузырей производится с помощью прямоугольной области. */

#include <iostream>
#ifdef _WIN32
#include <Windows.h>
#endif
#include "Module_14.hpp"

// безопасный ввод координаты
static int safe_enter(std::string invite_str, std::string error_str) {
    int X;
    do {
        std::cout << invite_str;
        std::cin >> X;
        if (X <= 0 || X > 12)
            std::cout << error_str;
    } while (X <= 0 || X > 12);
    
    return X;
}

// функция лопанья шариков
int blobPop(bool shell[12][12], int x1, int y1, int x2, int y2) {
    int popped = 0;

    for (int i = y1 - 1; i < y2; i++) {
        for (int j = x1 - 1; j < x2; j++) {
            if (shell[i][j]) {
                shell[i][j] = false;
                popped++;
                std::cout << "Pop!\n";
            }
        }
    }

    return popped;
}

// функция изменения цвета символов в консоли
static void changeColor(int color) {
#ifdef _WIN32
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, color);
#endif
}

// функция вывода на экран пупырки
static void print_shell(bool shell[12][12]) {
    changeColor(15);
    std::cout << "y\\x    1   2   3   4   5   6   7   8   9  10  11  12\n";
    std::cout << "     -------------------------------------------------\n";
    for (int i = 0; i < 12; i++) {
        changeColor(15);
        std::cout << " " << i + 1 << ((i + 1 < 10) ? "  " : " ");
        for (int j = 0; j < 12; j++) {
            changeColor(15);
            std::cout << " | ";
            if (shell[i][j]) {
                changeColor(10);
                std::cout << 'o';
            } else {
                changeColor(12);
                std::cout << 'x';
            }
        }
        changeColor(15);
        std::cout << " |\n";
        std::cout << "     -------------------------------------------------\n";
    }
}

// функция инициализации пупырки
static void init_shell(bool shell[12][12]) {
    for (int i = 0; i < 12; i++)
        for (int j = 0; j < 12; j++)
            shell[i][j] = true;
}

void Task_14_5() {
    std::cout << equals << string_tasks[4] << equals;

    bool shell[12][12];
    int blobSum = 12 * 12;
    init_shell(shell);

    print_shell(shell);
    while (blobSum > 0) {
        // ввод координат
        int reg_1x = safe_enter("Введите координату X для 1 региона: ",
                                "ОШИБКА! Координата должна быть в пределах от 1 до 12!\n");
        int reg_1y = safe_enter("Введите координату Y для 1 региона: ",
                                "ОШИБКА! Координата должна быть в пределах от 1 до 12!\n");
        int reg_2x = safe_enter("Введите координату X для 2 региона: ",
                                "ОШИБКА! Координата должна быть в пределах от 1 до 12!\n");
        int reg_2y = safe_enter("Введите координату Y для 2 региона: ",
                                "ОШИБКА! Координата должна быть в пределах от 1 до 12!\n");
        
        // лопанье шариков
        blobSum -= blobPop(shell, reg_1x, reg_1y, reg_2x, reg_2y);

        // вывод на экран пупырки
        print_shell(shell);
    }

    std::cout << "Шарики в пупырке кончились!\n";
}
#endif
